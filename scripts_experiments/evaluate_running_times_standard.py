import argparse
import math

SOLVED = 0
MEMORYLIMIT = 1
TIMELIMIT = 2

TIMESHIFT = 1.0
INTEGRALSHIFT = 0

setting_encoding = [
    "         &          &          &         ",
    "$\\times$ &          &          &         ",
    "$\\times$ & $\\times$ &          &         ",
    "$\\times$ & $\\times$ & $\\times$ &         ",
    "$\\times$ & $\\times$ & $\\times$ & $\\times$"
]

setting_name = [
    "sym_0_doublelex_0_reflection_0_simple_0",
    "sym_1_doublelex_0_reflection_0_simple_0",
    "sym_1_doublelex_1_reflection_0_simple_0",
    "sym_1_doublelex_1_reflection_1_simple_0",
    "sym_1_doublelex_1_reflection_1_simple_1"
]

testset_name = {
    "maxcut_ssym": "maxcut",
    "miplib2017_ssym": "miplib2017",
    "minlplib_ssym": "minlplib",
    "sat2002_ssym": "sat2002"
    }

skipped_instances = [
    "unweighted_maxcut_games120.cip",
    "tokyometro.mps.gz"
]

def extract_statistics(results_file, timelim):

    statistics = dict()

    f = open(results_file, 'r')

    name = ""
    stats = None
    stats_solved = None
    for line in f:

        if line.startswith("@01"):
            name = line.split()[1].split('/')[-1]
            stats = {
                "status": SOLVED,
                "time": -1,
                "gap": -1
                }
        elif line.startswith("SCIP Status        : solving was interrupted [memory limit reached]"):
            stats["status"] = MEMORYLIMIT
        elif line.startswith("SCIP Status        : solving was interrupted [time limit reached]"):
            stats["status"] = TIMELIMIT
        elif line.startswith("Solving Time (sec)"):
            if stats["status"] == MEMORYLIMIT:
                stats["time"] = timelim
            else:
                stats["time"] = min(timelim, float(line.split()[-1]))
        elif line.startswith("Gap                :"):
            if line.split()[2] == "infinite":
                stats["gap"] = 10000.0
            else:
                stats["gap"] = float(line.split()[2])
        elif line.startswith("@04"):
            statistics[name] = stats

    f.close()

    return statistics

def print_line(stats, setting_name, solved_instances):

    time = 1.0
    gap = 0.0
    cnt = 0
    cnt_solved = 0
    time_solved = 1.0
    gap_solved = 0.0
    nsolved = 0

    for inst in stats:
        if inst in skipped_instances:
            continue
        time = math.pow(time, cnt/(cnt + 1)) * math.pow(stats[inst]["time"] + TIMESHIFT, 1/(cnt + 1))
        gap = (gap * cnt + stats[inst]["gap"]) / (cnt + 1)
        cnt += 1

        if inst in solved_instances:
            time_solved = math.pow(time_solved, cnt_solved/(cnt_solved + 1)) * math.pow(stats[inst]["time"] + TIMESHIFT, 1/(cnt_solved + 1))
            gap_solved = (gap_solved * cnt_solved + stats[inst]["gap"]) / (cnt_solved + 1)
            cnt_solved += 1

        if stats[inst]["status"] == SOLVED:
            nsolved += 1

    time -= TIMESHIFT
    time_solved -= TIMESHIFT
    print("    %s & %3d & %7.2f & %7.2f & %8.2f & %8.2f\\\\" % (setting_name, nsolved, time, time_solved, gap, gap_solved))

def get_solved_instances(statistics):

    solved_instances = set()

    for sett in statistics:
        for inst in statistics[sett] :
            if statistics[sett][inst]["status"] == SOLVED and not inst in skipped_instances:
                solved_instances.add(inst)

    return solved_instances

def display_header():

    print("% generated by evaluate_running_times_standard.py")
    print("\\begin{table}")
    print("  \caption{Comparison of running times and gaps for symmetric instances.}")
    print("  \label{tab:symmetricresults}")
    print("  \centering")
    print("  \\begin{tabular*}{\\textwidth}{@{}c@{\;\;\extracolsep{\\fill}}cccrrrrr@{}}")
    print("    \\toprule")
    print("    \\multicolumn{4}{c}{setting} & & \\multicolumn{2}{c}{time} & \\multicolumn{2}{c}{gap}\\\\")
    print("    \\cmidrule{1-4} \\cmidrule{6-7} \\cmidrule{8-9}")
    print("    sym. & row+col & refl. & simp. & \# solved & all & solved & all & solved\\\\")

def display_footer():

    print("    \\bottomrule")
    print("  \end{tabular*}")
    print("\end{table}")

def display_subheader(t, n_instances, n_solved):
    print("    \\midrule")
    print("    \\multicolumn{7}{@{}l}{%s (%d/%d):}\\\\" % (testset_name[t], n_instances, n_solved))

def display_tables(statistics):

    display_header()
    for t in statistics:
        solved_instances = get_solved_instances(statistics[t])
        n_stable = sum(1 for inst in statistics[t][0].keys() if not inst in skipped_instances)

        display_subheader(t, n_stable, len(solved_instances))
        for i in range(5):
            print_line(statistics[t][i], setting_encoding[i], solved_instances)
    display_footer()

if __name__ == "__main__":

    # create a parser for arguments
    parser = argparse.ArgumentParser(description='evaluates the running times for a test set')
    parser.add_argument('results', metavar='results', type=str, help='directory containing results')
    parser.add_argument('--tname', metavar='tname', type=str, action='append', help='name of test set to be added')
    parser.add_argument('--timelim', metavar='timelim', type=int, default=7200, help='time limit of experiments')

    args = parser.parse_args()

    statistics = { t: dict() for t in args.tname}
    statistics_solved = { t: dict() for t in args.tname}

    for t in args.tname:
        for i in range(5):
            name = args.results + "/"  + f"check.{t}.scip-10.0.0.0.linux.x86_64.gnu.opt.spx2.none.moskito.{setting_name[i]}.out"
            statistics[t][i] = extract_statistics(name, args.timelim)

    display_tables(statistics)
