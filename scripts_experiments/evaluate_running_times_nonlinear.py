import argparse
import math
import matplotlib.pyplot as plt

SOLVED = 0
MEMORYLIMIT = 1
TIMELIMIT = 2

TIMESHIFT = 1.0
INTEGRALSHIFT = 0

def extract_statistics(results_file, timelim):

    statistics = dict()

    f = open(results_file, 'r')

    name = ""
    stats = None
    for line in f:

        if line.startswith("@01"):
            name = line.split()[1].split('/')[-1]
            sname = name.split('_')
            name = (int(sname[1][1:]), int(sname[2][1:]))
            stats = {
                "status": SOLVED,
                "time": -1,
                "gap": -1,
                "primaldual": -1
                }
        elif line.startswith("SCIP Status        : solving was interrupted [memory limit reached]"):
            stats["status"] = MEMORYLIMIT
        elif line.startswith("SCIP Status        : solving was interrupted [time limit reached]"):
            stats["status"] = TIMELIMIT
        elif line.startswith("Solving Time (sec)"):
            if stats["status"] == MEMORYLIMIT:
                stats["time"] = timelim
            else:
                stats["time"] = min(timelim, float(line.split()[-1]))
        elif line.startswith("Gap                :"):
            stats["gap"] = float(line.split()[2])
        elif line.startswith("  primal-dual      :"):
            stats["primaldual"] = float(line.strip().split()[2])
        elif line.startswith("@04"):
            statistics[name] = stats

    f.close()

    return statistics

def print_summary_line(stats, setting_name):

    gmean2 = 1.0
    gmean3 = 1.0
    gintegral2 = 1.0
    gintegral3 = 1.0
    cnt2 = 0
    cnt3 = 0
    nsolved2 = 0
    nsolved3 = 0

    for (n,d) in stats:
        if d == 2:
            gmean2 = math.pow(gmean2, cnt2/(cnt2 + 1)) * math.pow(stats[n,d]["time"] + TIMESHIFT, 1/(cnt2 + 1))
            gintegral2  = math.pow(gintegral2, cnt2/(cnt2 + 1)) * math.pow(stats[n,d]["primaldual"], 1/(cnt2 + 1))
            cnt2 += 1

            if stats[n,d]["status"] == SOLVED:
                nsolved2 += 1
        else:
            assert d == 3
            gmean3 = math.pow(gmean3, cnt3/(cnt3 + 1)) * math.pow(stats[n,d]["time"] + TIMESHIFT, 1/(cnt3 + 1))
            gintegral3  = math.pow(gintegral3, cnt3/(cnt3 + 1)) * math.pow(stats[n,d]["primaldual"], 1/(cnt3 + 1))
            cnt3 += 1

            if stats[n,d]["status"] == SOLVED:
                nsolved3 += 1

    gmean2 -= TIMESHIFT
    gmean3 -= TIMESHIFT
    gintegral2 -= INTEGRALSHIFT
    gintegral3 -= INTEGRALSHIFT
    print("%20s & %3d & %7.2f & %11.1f & %3d & %7.2f & %11.1f\\\\" % (setting_name, nsolved2, gmean2, gintegral2, nsolved3, gmean3, gintegral3))

def print_detailed_line(statistics, n, dim, field):

    line = "%6d" % n
    if field == "time":
        for i in range(7):
            line += ' & \\num{%7.2f}' % statistics[i][n,dim][field]
        line += ' & \\num{%7.2f}\\\\' % statistics[-1][n,dim][field]
    else:
        for i in range(7):
            line += ' & \\num{%7.0f}' % statistics[i][n,dim][field]
        line += ' & \\num{%7.0f}\\\\' % statistics[-1][n,dim][field]
    print(line)

def display_summary_header(tname):

    print("% generated by evaluate_running_times_nonlinear.py")
    print("\\begin{table}")
    print("  \caption{Comparison of running times and primal-dual integrals for %s test set.}" % tname)
    print("  \label{tab:%s}" % tname)
    print("  \centering")
    print("  \\begin{tabular*}{\\textwidth}{@{}l@{\;\;\extracolsep{\\fill}}rrrrrr@{}}")
    print("    \\toprule")
    print("    & \multicolumn{3}{c}{dimension 2} & \multicolumn{3}{c}{dimension 3}\\\\")
    print("    \cmidrule{2-4} \cmidrule{5-7}")
    print("    setting & \# solved & time & primal-dual & \# solved & time & primal-dual\\\\")
    print("    \midrule")

def display_detailed_header(tname, dim):

    print("% generated by evaluate_running_times_nonlinear.py")
    print("\\begin{table}")
    print("  \caption{Running times and primal-dual integrals for %s test set and dimension %d.}" % (tname,dim))
    print("  \label{tab:details%s%d}" % (tname,dim))
    print("  \centering")
    print("  \scriptsize")
    print("  \\begin{tabular*}{\\textwidth}{@{}l@{\;\;\extracolsep{\\fill}}rrrrrrrr@{}}")
    print("    \\toprule")
    print("    & \multicolumn{8}{c}{setting}\\\\")
    print("    \cmidrule{2-9}")
    print("    \# items & sym0 & sym1 & sym2 & sym3 & sym4 & sym5 & sym6 & auto.\\\\")

def display_footer():

    print("    \\bottomrule")
    print("  \end{tabular*}")
    print("\end{table}")

def display_summary_tables(statistics, tname):

    display_summary_header(tname)
    for i in range(7):
        print_summary_line(statistics[i], f"sym{i}")
    print_summary_line(statistics[-1], "automatic")
    display_footer()

def display_intermediate_header(header):

    print("    \midrule")
    print("    \\multicolumn{9}{@{}l}{%s}\\\\" % header)

def display_detailed_tables(statistics, tname, dim):

    N = [n for (n,d) in statistics[0] if d == dim]
    N.sort()

    display_detailed_header(tname, dim)

    display_intermediate_header("running time in seconds:")
    for n in N:
        print_detailed_line(statistics, n, dim, "time")

    display_intermediate_header("primal-dual integral:")
    for n in N:
        print_detailed_line(statistics, n, dim, "primaldual")

    display_footer()

if __name__ == "__main__":

    # create a parser for arguments
    parser = argparse.ArgumentParser(description='evaluates the running times for a test set')
    parser.add_argument('results', metavar='results', type=str, help='directory containing results')
    parser.add_argument('tname', metavar='tname', type=str, help='name of test set')
    parser.add_argument('--timelim', metavar='timelim', type=int, default=7200, help='time limit of experiments')
    parser.add_argument('--full', default=False, action='store_true', help='whether full results shall be printed')

    args = parser.parse_args()

    statistics = dict()

    for i in range(7):
        name = args.results + "/"  + f"check.{args.tname}_sym{i}.scip-10.0.0.0.linux.x86_64.gnu.opt.spx2.none.moskito.nosym_nonlinear.out"
        statistics[i] = extract_statistics(name, args.timelim)

    name = args.results + "/"  + f"check.{args.tname}_sym0.scip-10.0.0.0.linux.x86_64.gnu.opt.spx2.none.moskito.sym_nonlinear.out"
    statistics[-1] = extract_statistics(name, args.timelim)

    if not args.full:
        display_summary_tables(statistics, args.tname)
    else:
        display_detailed_tables(statistics, args.tname, 2)
        display_detailed_tables(statistics, args.tname, 3)
